generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum UserRole {
  ADMIN
  INSTRUCTOR
  STUDENT
}

enum MembershipStatus {
  PENDING
  ACTIVE
  EXPIRED
  REJECTED
}

enum EventType {
  TOURNAMENT
  CAMP
  SEMINAR
}

enum EventStatus {
  DRAFT
  UPCOMING
  ONGOING
  COMPLETED
  CANCELLED
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum PaymentType {
  MEMBERSHIP
  RENEWAL
  TOURNAMENT
}

enum ApprovalStatus {
  PENDING
  APPROVED
  REJECTED
}

enum BracketStatus {
  DRAFT
  LOCKED
  IN_PROGRESS
  COMPLETED
}

enum MatchStatus {
  SCHEDULED
  LIVE
  COMPLETED
  CANCELLED
}

enum VoucherApplicability {
  MEMBERSHIP
  TOURNAMENT
  CAMP
  ALL
}

enum NotificationType {
  APPROVAL
  REJECTION
  BELT_PROMOTION
  EVENT_REMINDER
  GENERAL
}

enum VerificationStatus {
  VERIFIED
  PENDING_VERIFICATION
  REJECTED
}

model User {
  id                    String           @id @default(uuid())
  email                 String           @unique
  passwordHash          String
  role                  UserRole         @default(STUDENT)

  // Personal Info
  name                  String
  phone                 String?
  countryCode           String?          @default("+91")
  dateOfBirth           DateTime?
  height                Float?           // cm
  weight                Float?           // kg
  city                  String?
  state                 String?
  country               String?          @default("India")
  profilePhotoUrl       String?

  // Guardian Info
  fatherName            String?
  fatherPhone           String?

  // Membership (STUDENT only)
  membershipNumber      String?          @unique  // Format: KKI-YYYY-CITY-#####
  membershipStatus      MembershipStatus? @default(PENDING)
  membershipStartDate   DateTime?
  membershipEndDate     DateTime?

  // Relationships
  dojoId                String?
  dojo                  Dojo?            @relation(fields: [dojoId], references: [id])
  primaryInstructorId   String?
  primaryInstructor     User?            @relation("InstructorStudents", fields: [primaryInstructorId], references: [id])
  students              User[]           @relation("InstructorStudents")

  // Belt Ranking
  currentBeltRank       String?          @default("White")
  verificationStatus    VerificationStatus? @default(VERIFIED)

  // Approval Tracking
  isInstructorApproved  Boolean          @default(false)
  instructorApprovedAt  DateTime?
  approvedBy            String?
  approver              User?            @relation("UserApprover", fields: [approvedBy], references: [id])
  approvedUsers         User[]           @relation("UserApprover")
  approvedAt            DateTime?

  // Relations
  beltHistory           BeltHistory[]    @relation("StudentBeltHistory")
  promotedBelts         BeltHistory[]    @relation("PromoterBeltHistory")
  beltVerificationRequests BeltVerificationRequest[] @relation("StudentVerificationRequests")
  reviewedVerifications BeltVerificationRequest[] @relation("InstructorReviews")
  createdEvents         Event[]
  registrations         EventRegistration[]
  approvedRegistrations EventRegistration[] @relation("RegistrationApprover")

  // Tournament Relations
  wonMatches            Match[]          @relation("MatchWinner")
  matchesAsFighterA     Match[]          @relation("FighterA")
  matchesAsFighterB     Match[]          @relation("FighterB")
  tournamentResults     TournamentResult[]

  // Other
  uploadedGallery       Gallery[]        @relation("GalleryUploader")
  approvedGallery       Gallery[]        @relation("GalleryApprover")
  createdVouchers       VoucherCode[]
  notifications         Notification[]
  trainingSessions      TrainingSession[]
  posts                 Post[]
  monthlyRecognitions   MonthlyRecognition[]

  // Audit & Notes
  profileViews          ProfileView[]    @relation("ProfileViewed")
  viewedProfiles        ProfileView[]    @relation("ProfileViewer")
  notesReceived         StudentNote[]    @relation("StudentNotes")
  notesAuthored         StudentNote[]    @relation("AuthoredNotes")
  payments              Payment[]
  merchOrders           MerchOrder[]

  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
}

model Dojo {
  id           String   @id @default(uuid())
  name         String
  dojoCode     String   @unique  // MUM, DEL, BLR
  city         String
  state        String?
  country      String?
  address      String?
  contactEmail String?
  contactPhone String?
  latitude     Float?
  longitude    Float?

  instructors  User[] // Ideally filtered by role in app logic, but relation exists via User.dojoId

  gallery      Gallery[]
  events       Event[]

  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}

model BeltHistory {
  id            String   @id @default(uuid())
  studentId     String
  student       User     @relation("StudentBeltHistory", fields: [studentId], references: [id])
  oldBelt       String?
  newBelt       String
  promotedBy    String
  promoter      User     @relation("PromoterBeltHistory", fields: [promotedBy], references: [id])
  promotionDate DateTime @default(now())
  notes         String?
  createdAt     DateTime @default(now())
}

model Event {
  id                    String      @id @default(uuid())
  type                  EventType
  name                  String
  description           String?
  imageUrl              String?
  startDate             DateTime
  endDate               DateTime
  location              String?
  dojoId                String?
  dojo                  Dojo?       @relation(fields: [dojoId], references: [id])

  // Registration
  registrationDeadline  DateTime
  maxParticipants       Int?

  // Pricing
  memberFee             Float
  nonMemberFee          Float

  // Categories (JSON array)
  categories            Json?       // [{age: "18-35", weight: "<70kg", belt: "Brown"}]

  status                EventStatus @default(UPCOMING)
  createdBy             String
  creator               User        @relation(fields: [createdBy], references: [id])

  registrations         EventRegistration[]
  brackets              TournamentBracket[]
  results               TournamentResult[]
  gallery               Gallery[]
  specificVouchers      VoucherCode[]
  payments              Payment[]
  notifications         Notification[]

  createdAt             DateTime    @default(now())
  updatedAt             DateTime    @updatedAt
}

model EventRegistration {
  id                      String         @id @default(uuid())
  eventId                 String
  event                   Event          @relation(fields: [eventId], references: [id])
  userId                  String
  user                    User           @relation(fields: [userId], references: [id])

  // Category Selection
  categoryAge             String?
  categoryWeight          String?
  categoryBelt            String?
  eventType               String?        // "Kata", "Kumite", "Both"

  // Payment
  paymentStatus           PaymentStatus  @default(PENDING)
  paymentAmount           Float?
  voucherCodeUsed         String?
  discountAmount          Float          @default(0)
  finalAmount             Float?

  // Approval (tournaments only)
  approvalStatus          ApprovalStatus @default(PENDING)
  approvedBy              String?
  approver                User?          @relation("RegistrationApprover", fields: [approvedBy], references: [id])
  approvedAt              DateTime?

  // Non-member tracking
  isNonMember             Boolean        @default(false)
  nonMemberAccessExpires  DateTime?

  registeredAt            DateTime       @default(now())
  updatedAt               DateTime       @updatedAt

  @@unique([eventId, userId])
}

model TournamentBracket {
  id                  String        @id @default(uuid())
  eventId             String
  event               Event         @relation(fields: [eventId], references: [id])

  // Category
  categoryName        String        // "18-35, 60-70kg, Brown Belt"
  categoryAge         String?
  categoryWeight      String?
  categoryBelt        String?

  totalParticipants   Int
  bracketType         String        @default("SINGLE_ELIMINATION")
  bracketData         Json?         // Full bracket tree structure

  status              BracketStatus @default(DRAFT)

  matches             Match[]
  results             TournamentResult[]

  createdAt           DateTime      @default(now())
  lockedAt            DateTime?
  completedAt         DateTime?
}

model Match {
  id                  String      @id @default(uuid())
  bracketId           String
  bracket             TournamentBracket @relation(fields: [bracketId], references: [id])

  // Match Position
  roundNumber         Int         // 1=R1, 2=R2, 3=QF, 4=SF, 5=Final, 6=3rdPlace
  roundName           String      // "Round 1", "Quarter-Finals", etc.
  matchNumber         Int
  positionInBracket   String?

  // Fighters
  fighterAId          String?
  fighterA            User?       @relation("FighterA", fields: [fighterAId], references: [id])
  fighterBId          String?
  fighterB            User?       @relation("FighterB", fields: [fighterBId], references: [id])
  fighterAName        String?
  fighterBName        String?

  // Result
  fighterAScore       Int?
  fighterBScore       Int?
  winnerId            String?
  winner              User?       @relation("MatchWinner", fields: [winnerId], references: [id])
  isBye               Boolean     @default(false)

  nextMatchId         String?
  status              MatchStatus @default(SCHEDULED)

  scheduledDateTime   DateTime?
  startedAt           DateTime?
  completedAt         DateTime?
  notes               String?
  createdAt           DateTime    @default(now())
}

model TournamentResult {
  id                  String            @id @default(uuid())
  eventId             String
  event               Event             @relation(fields: [eventId], references: [id])
  userId              String
  user                User              @relation(fields: [userId], references: [id])
  bracketId           String
  bracket             TournamentBracket @relation(fields: [bracketId], references: [id])

  categoryName        String
  finalRank           Int               // 1, 2, 3, 4...
  medal               String?           // GOLD, SILVER, BRONZE

  totalMatches        Int               @default(0)
  matchesWon          Int               @default(0)
  matchesLost         Int               @default(0)
  eliminatedInRound   String?
  eliminatedByUserId  String?

  createdAt           DateTime          @default(now())
}

model Gallery {
  id                String    @id @default(uuid())
  uploadedBy        String
  uploader          User      @relation("GalleryUploader", fields: [uploadedBy], references: [id])
  imageUrl          String

  eventId           String?
  event             Event?    @relation(fields: [eventId], references: [id])
  dojoId            String?
  dojo              Dojo?     @relation(fields: [dojoId], references: [id])

  isApproved        Boolean   @default(false)
  isPublicFeatured  Boolean   @default(false)
  approvedBy        String?
  approver          User?     @relation("GalleryApprover", fields: [approvedBy], references: [id])
  approvedAt        DateTime?

  caption           String?
  uploadedAt        DateTime  @default(now())
}

model VoucherCode {
  id                String                @id @default(uuid())
  code              String                @unique
  discountAmount    Float                 // Fixed amount only
  applicableTo      VoucherApplicability
  specificEventId   String?
  specificEvent     Event?                @relation(fields: [specificEventId], references: [id])
  maxUsesPerUser    Int                   @default(1)
  expiryDate        DateTime
  isActive          Boolean               @default(true)
  createdBy         String
  creator           User                  @relation(fields: [createdBy], references: [id])
  createdAt         DateTime              @default(now())
}

model Notification {
  id              String           @id @default(uuid())
  userId          String
  user            User             @relation(fields: [userId], references: [id])
  type            NotificationType
  title           String
  message         String
  relatedEventId  String?
  relatedEvent    Event?           @relation(fields: [relatedEventId], references: [id])
  relatedMatchId  String?
  isRead          Boolean          @default(false)
  emailSent       Boolean          @default(false)
  emailSentAt     DateTime?
  createdAt       DateTime         @default(now())
}

model TrainingSession {
  id          String   @id @default(uuid())
  userId      String
  user        User     @relation(fields: [userId], references: [id])
  date        DateTime
  duration    Int      // in minutes
  intensity   String   // LOW, MEDIUM, HIGH
  focus       String?  // e.g., "Kata", "Kumite", "Conditioning"
  notes       String?
  createdAt   DateTime @default(now())
}

enum ContentType {
  IMAGE
  TEXT
}

model SiteContent {
  id          String      @id @default(uuid())
  key         String      @unique
  value       String
  type        ContentType
  description String?
  updatedAt   DateTime    @updatedAt
}

enum PostType {
  BLOG
  MEDIA_MENTION
}

enum PostStatus {
  DRAFT
  PENDING
  PUBLISHED
}

model Post {
  id            String    @id @default(uuid())
  type          PostType
  status        PostStatus @default(DRAFT)
  title         String
  slug          String    @unique
  content       String?   // HTML content for blogs
  excerpt       String?
  imageUrl      String?
  externalLink  String?   // For media mentions
  sourceName    String?   // For media mentions (e.g. "Times of India")
  attachmentUrl String?   // For PDF uploads

  publishedAt   DateTime  @default(now())
  authorId      String
  author        User      @relation(fields: [authorId], references: [id])

  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt
}

model MonthlyRecognition {
  id        String   @id @default(uuid())
  month     Int      // 1-12
  year      Int
  type      UserRole // INSTRUCTOR or STUDENT (Reusing UserRole enum, though strictly it's a subset)
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())

  @@unique([month, year, type, userId]) // Prevent duplicate awards for same person in same month/type
}

model BeltVerificationRequest {
  id              String         @id @default(uuid())
  studentId       String
  student         User           @relation("StudentVerificationRequests", fields: [studentId], references: [id])
  requestedBelt   String         // Belt color being claimed
  examDate        DateTime       // Date when student claims they passed the belt exam
  reason          String?        // Optional explanation from student
  status          ApprovalStatus @default(PENDING)
  reviewedBy      String?
  reviewer        User?          @relation("InstructorReviews", fields: [reviewedBy], references: [id])
  reviewedAt      DateTime?
  rejectionReason String?        // Why it was rejected (if applicable)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  @@index([studentId])
  @@index([status])
}

model Payment {
  id                String        @id @default(uuid())
  type              PaymentType
  amount            Float         // Base amount (e.g. 250)
  taxAmount         Float         // GST amount
  totalAmount       Float         // amount + taxAmount
  currency          String        @default("INR")

  // Razorpay
  razorpayOrderId   String        @unique
  razorpayPaymentId String?
  razorpaySignature String?

  status            PaymentStatus @default(PENDING)

  // Who paid (null for new registrations before user creation)
  userId            String?
  user              User?         @relation(fields: [userId], references: [id])

  // For registration payments - store form data until payment completes
  registrationData  Json?

  // For event/tournament payments
  eventId           String?
  event             Event?        @relation(fields: [eventId], references: [id])

  description       String?
  paidAt            DateTime?
  createdAt         DateTime      @default(now())
  updatedAt         DateTime      @updatedAt

  @@index([razorpayOrderId])
  @@index([userId])
  @@index([status])
}

model ProfileView {
  id         String   @id @default(uuid())
  studentId  String
  student    User     @relation("ProfileViewed", fields: [studentId], references: [id])
  viewedBy   String
  viewer     User     @relation("ProfileViewer", fields: [viewedBy], references: [id])
  viewedAt   DateTime @default(now())

  @@index([studentId])
  @@index([viewedBy])
  @@index([viewedAt])
}

model StudentNote {
  id         String   @id @default(uuid())
  studentId  String
  student    User     @relation("StudentNotes", fields: [studentId], references: [id])
  createdBy  String
  author     User     @relation("AuthoredNotes", fields: [createdBy], references: [id])
  noteText   String   @db.Text
  isPrivate  Boolean  @default(false) // Private notes only visible to the author
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([studentId])
  @@index([createdBy])
}

// ========== MERCHANDISE STORE ==========

model Product {
  id            String   @id @default(uuid())
  name          String
  description   String?  @db.Text
  price         Float
  comparePrice  Float?   // Original price for showing discount
  category      String   @default("APPAREL") // APPAREL, EQUIPMENT, ACCESSORIES
  images        String[] // Array of image URLs
  sizes         String[] // S, M, L, XL, etc.
  inStock       Boolean  @default(true)
  stockCount    Int      @default(0)
  featured      Boolean  @default(false)
  isActive      Boolean  @default(true)
  orderItems    MerchOrderItem[]
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model MerchOrder {
  id              String   @id @default(uuid())
  userId          String
  user            User     @relation(fields: [userId], references: [id])
  items           MerchOrderItem[]
  status          OrderStatus @default(PENDING)
  totalAmount     Float
  razorpayOrderId String?
  razorpayPaymentId String?
  shippingName    String?
  shippingPhone   String?
  shippingAddress String?  @db.Text
  shippingCity    String?
  shippingState   String?
  shippingPincode String?
  notes           String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([userId])
}

model MerchOrderItem {
  id        String   @id @default(uuid())
  orderId   String
  order     MerchOrder @relation(fields: [orderId], references: [id])
  productId String
  product   Product  @relation(fields: [productId], references: [id])
  size      String?
  quantity  Int      @default(1)
  price     Float    // Price at time of purchase
  createdAt DateTime @default(now())

  @@index([orderId])
  @@index([productId])
}

enum OrderStatus {
  PENDING
  CONFIRMED
  SHIPPED
  DELIVERED
  CANCELLED
}
